#!/usr/bin/env python3
import argparse
import re
import os
import csv
import glob
import time
from datetime import timedelta
import tracemalloc

# TODO: decide what we want our output to look like
# TODO: do we need a separate remove non-alphanumeric function?
# TODO: add arguments such as max length, allow underscores, species name, custom replace characters, custom regex. 
# TODO: Make sure all arguements have defaults
# TODO: make sure chop can't return ___ only
  
def main():
  print('Commencing Squeakuences Cleanup')
  print('================================')

  parser = setupParser()
  args = parser.parse_args()
  inputPath = args.input
  outputPath = args.output
  logFlag = args.log
  fileNameFlag = args.addFileName

  messagesForArgs(logFlag, fileNameFlag)
  print('--------------------------------')

  inputType = resolveInput(inputPath)
  print('You\'ve input a ' + inputType + '.')
  toProcess = inputList(inputType, inputPath)
  fileNameList = getFaNameExt(toProcess)
  print('The following file(s) will be cleaned: ' + str(fileNameList))
  print('--------------------------------')

  ouputPath = checkOutputArg(outputPath)

  logPath = outputPath + '/log.tsv'
  if logFlag is True:
    checkExistingLogFile(logPath)
    createLogFile(logPath)
  
  for file in toProcess:
    squeakify(file, ouputPath, logFlag, logPath, fileNameFlag)
    print('--------------------------------')

  print('Ta-da! Squeaky clean sequence ids!')
  #print('New squeaky clean files and other output files can be found in: ' + outputPath)

def squeakify(file, write, logFlag, logPath, fileNameFlag):
  if logFlag is True:
    logData = {}
    startLog(logData, file)  

  sequenceIdCount = 0
  idDict = {}
  idDuplicatesList = []

  faFileNameExt, fastaHandle, faFileName = loadFile(file)
  print('Now processing ' + faFileNameExt)

  squeakyPath = write + '/' + faFileName + '_squeak.fa'
  squeakyDictPath = write + '/' + faFileName + '_modSeqs.tsv'

  checkExisting(squeakyDictPath, squeakyPath)

  print('...')

  for line in fastaHandle:
    if isSequenceId(line):
      sequenceIdCount += 1
      startId = stripSequenceId(line)
      endId = camelCase(startId)
      endId = removeSpaces(endId)
      endId = removeNonAlphanumeric(endId)
      if fileNameFlag is True:
        endId = attachFileName(endId, faFileName)
      endId = chop(endId)
      
      if checkForDuplicates(endId, idDict):
        startId, endId = resolveDuplicate(startId, endId, idDuplicatesList)
        endId = chop(endId)
        
      idDict.update({startId: endId})

      writeLine(squeakyPath, endId, True)

    else:
      writeLine(squeakyPath, line, False)

  writeModIdFile(write + '/' + faFileName, idDict)

  if logFlag is True:
    endLog(logData, faFileNameExt, os.path.abspath(squeakyPath))
    writeLogFile(logData, logPath, sequenceIdCount)

  print(faFileNameExt + ' complete!')

def setupParser():
  parser = argparse.ArgumentParser()
  # Add parser arguments. ex: parser.add_argument('-l', '--long_name', help='What is it for?', required=True/False)
  parser.add_argument('-i', '--input', metavar='file/dir_path', help='''Path to fasta file(s) to clean.
                                                You can provide the path to a single fasta file or a directory containing multiple fasta files.
                                                Squeakuences will not search subdirectories.
                                                This can be the full path or relative to the squeakuences.py file location.''', required=True)
  parser.add_argument('-o', '--output', metavar='dir_path', help='''Path to output folder where files generated by Squeakuences will be written.
                                                This can be the full path or relative to the squeakuences.py file location.
                                                If this directory path does not exist at runtime, Squeakuences will create it for you.''', required=True)
  parser.add_argument('-l', '--log', help='When activated, Squeakuences will generate a log file with processing info from each fasta file cleaned.', required=False, action='store_true')
  parser.add_argument('-f', '--addFileName', help='When activated, Squeakuences will add the file name to the beginning of all sequences cleaned.', required=False, action='store_true')
  return parser

def messagesForArgs(logFileFlag, fileNameFlag):
  if logFileFlag == fileNameFlag == False:
    print('No flags detected in command.')
  else:
    if fileNameFlag is True:
      print('You\'ve activated the -f flag.\nThe file name will be inserted at the beginning of all sequences cleaned.')
    if logFileFlag is True:
      print('You\'ve activated the -l flag.\nA log file with information about each fasta file processed will be written in the output directory.')

#####################################################
# RESOLVE USER INPUT                                #
#####################################################
def resolveInput(userInput):
  if os.path.isfile(userInput):
    return 'file'
  
  if os.path.isdir(userInput):
    fullDirPath = checkDirPath(userInput)
    return 'directory'
  
def checkDirPath(userInput):
  if os.path.isabs(userInput):
    return userInput
  else:
    cwd = os.getcwd()
    if cwd == '/':
      fullPath = '/' + userInput
    else:
      fullPath =  os.getcwd() + '/' + userInput
  return fullPath

#####################################################
# COLLECT FILES                                     #
#####################################################
def inputList(type, userInput):
  toSqueakify = []
  if type == 'file':
    toSqueakify.append(userInput)
  if type == 'directory':
    toSqueakify = glob.glob(userInput + '/*.fa*')
  for file in toSqueakify:
    index = toSqueakify.index(file)
    toSqueakify[index] = os.path.abspath(file)
  return toSqueakify

def getFaNameExt(inputList):
  faNameExtList = []
  for filePath in inputList:
    faNameExtList.append(filePath.split('/')[-1])
  return faNameExtList

#####################################################
# CHECK FOR EXISTING FILES                          #
#####################################################

def checkOutputArg(ouputDirectoryPath):
  if not os.path.isdir(ouputDirectoryPath):
    os.mkdir(ouputDirectoryPath)
    print('The provided output path does not lead to an existing directory.')
    print('A directory was created at that location.')
    print('--------------------------------')
  return ouputDirectoryPath

def checkExisting(squeakyDictPath, squeakyPath):
  if os.path.exists(squeakyDictPath):
    os.remove(squeakyDictPath)
    print('Existing squeaky dictionary file deleted.')

  if os.path.exists(squeakyPath):
    os.remove(squeakyPath)
    print('Existing squeaky fa file deleted.')

def checkExistingLogFile(logPath):
  if os.path.exists(logPath):
    os.remove(logPath)
    print('Existing log file deleted.')
    print('--------------------------------')

#####################################################
# SQUEAKIFY FUNCTIONS                               #
#####################################################

def loadFile(file):
  faFileNameExt = os.path.basename(file)
  fastaHandle = open(file, 'r')
  faFileName = os.path.splitext(faFileNameExt)[0]
  return faFileNameExt, fastaHandle, faFileName

def isSequenceId(line):
  return line.startswith('>')

def stripSequenceId(line):
  line = line.strip('>')
  line = line.strip('\n')
  return line

def camelCase(sequenceId):
  capList = []
  wordList = re.split(r'([^a-zA-Z0-9])', sequenceId)
  for word in wordList:
    capWord = word[:1].upper() + word[1:]
    capList.append(capWord)
  camelCaseSequence = ''.join(capList)
  return camelCaseSequence

def removeSpaces(sequenceId):
  modifiedId = re.sub(r'\s', '', sequenceId)
  return modifiedId

def removeNonAlphanumeric(sequenceId):
  modifiedId = re.sub(r'[^a-zA-Z0-9\s]', '', sequenceId)
  return modifiedId

# Optional?
def remove_non_english_characters(sequenceId):
  # TODO: Remove any non-english characters
  # Regex: /<-[a..zA..Z\s]>+/  <<< Do we need this to include numbers? This is saying anything that isn't an english alphabetic letter
  return

def attachFileName(sequenceId, attachFileName):
  attachFileName = camelCase(attachFileName)
  attachFileName = removeSpaces(attachFileName)
  attachFileName = removeNonAlphanumeric(attachFileName)
  sequenceIdLower = sequenceId.lower()
  attachFileNameLower = attachFileName.lower()

  if sequenceIdLower.startswith(attachFileNameLower):
    underscoreindex = len(attachFileName)
    modifiedId = sequenceId[:underscoreindex] + '_' + sequenceId[underscoreindex:]
  else:
    modifiedId = attachFileName + '_' + sequenceId
  return modifiedId
    
def chop(sequenceId, max = 70):
  length = len(sequenceId)

  if length < max:
    return sequenceId
  else:
    sequenceId = re.sub(r'___', '', sequenceId)
    nameComponents = []
    nameComponents = re.findall(r'[A-Z][^A-Z]*', sequenceId)
    middle = len(nameComponents) // 2
    del nameComponents[middle:middle+1]
    nameComponents.insert(middle, '___')
    newName = ''.join(nameComponents)
    return chop(newName, max)
  
def checkForDuplicates(sequenceId, idDict):
  if sequenceId in idDict.values():
    return True
  else:
    return False

def resolveDuplicate(startSequenceId, modSequenceId, dupsList):
  existing = dupsList.count(modSequenceId)
  nextCount = existing + 1 
  startDupId = startSequenceId + '_' + str(nextCount)
  endDupId = modSequenceId + '_' + str(nextCount)
  dupsList.append(modSequenceId)
  return startDupId, endDupId

def writeLine(faFile, line, sequence):
  with open(faFile, 'a') as file:
    if sequence is True:
      file.write('>' + line + '\n')
    else:
      file.write(line)
  file.close()
  
def writeModIdFile(faFileName, idDictInput):
  fileExtension = os.path.splitext(faFileName)
  newFileName = fileExtension[0] + '_modSeqs.tsv'
  
  with open(newFileName, 'w') as tsvfile:
    writer = csv.writer(tsvfile, delimiter='\t')
    for k, v in idDictInput.items():
      writer.writerow([k, v])
  tsvfile.close()

#####################################################
# LOG FILE FUNCTIONS                                #
#####################################################

def startLog(logDataDict, file):
  logDataDict.update({'start_time': time.perf_counter()})
  logDataDict.update({'start_file_size': round(os.path.getsize(file)/1000000, 2)})
  tracemalloc.start()
  return logDataDict

def endLog(logDataDict, faFileNameExt, squeakyFile):
  logDataDict.update({'file_name': faFileNameExt})
  logDataDict.update({'end_file_size': round(os.path.getsize(squeakyFile)/1000000, 2)})
  logDataDict.update({'memory': tracemalloc.get_traced_memory()[1]})
  tracemalloc.stop()
  logDataDict.update({'end_time': time.perf_counter()})
  duration = timedelta(seconds=logDataDict['end_time'] - logDataDict['start_time'])
  logDataDict.update({'duration': str(duration)})
  return logDataDict

def createLogFile(logPath):
  with open(logPath, 'a') as file:
    file.write('File Name\tProcessing Time (Hours: Minutes: Seconds)\tMemory (peak size of memory blocks traced in bytes)\tStarting File Size (MB)\tEnding File Size (MB)\tNumber of sequences cleaned\n')
  file.close()

def writeLogFile(logDataDict, logPath, processedIdCount):
  with open(logPath, 'a') as file:
    file.write(logDataDict['file_name'] + '\t' + logDataDict['duration'] + '\t' + 
               str(logDataDict['memory']) + '\t' + str(logDataDict['start_file_size']) + '\t' + str(logDataDict['end_file_size']) + '\t' + str(processedIdCount) + '\n')
  file.close()

if __name__ == '__main__':
  main()
